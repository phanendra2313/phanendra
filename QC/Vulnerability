https://security.web.cern.ch/security/recommendations/en/codetools/c.shtml 

https://sgros-students.blogspot.com/2017/01/vulnerabilities-in-cc-code.html

Buffer overflow :
ppens when the data gets written beyond the boundaries of an array (buffer). 
This way data gets written to a portion of memory which does not belong to the program variable that references the array.
gets, strcpy, strcat, sprintf

Format string vulnerability:
occurs if an attacker is able to specify the format string to a format function. 
If the format string that is received differs from that which is expected, such as being longer or shorter than the allocated data space, 
the program may crash, quit or make up for the missing information by reading extra data from the stack; 
allowing the execution of malicious code.
Format functions are functions that have a variable amount of arguments and expect a format string as argument.
fprint, printf, sprintf, snprintf, vfprintf, vprintf

void foo(char *val)
    {
        printf(val);
    }

    int main(int argc, char **argv)
    {
        char buf[100] = "Hi %x %x\n";
        foo(buf);
        return 0;
    }
    
    Problem with code is that printf in foo will print content of stack. This can happen because printf accept variable 
    number of arguments and does not check for mismatch of number of format specifiers and arguments passed after format string.

Integer overflow:
Two kinds of integer errors that can lead to exploitable vulnerabilities exist: integer overflows and integer signedness errors
When an attempt is made to store a value greater than this maximum value it is known as an integer overflow. 
This can cause a program that does not expect this to fail or become vulnerable: 
if used in conjunction with memory allocation, too little memory might be allocated causing a possible heap overflow.

Signedness errors occur when an unsigned variable is interpreted as signed, or when a signed variable is interpreted as unsigned. 
possibly causing a overflow if used in conjunction with a copy operation (e.g. memcpy expects an unsigned integer as size argument and when passed a negative signed integer, 
it will assume this is a large unsigned value). Example code of integer overflow:


int main(int argc, char **argv)
    {
        int val = 0x7fffffff;   /*2147483647*/
        print("%d\n", val);
        val = val + 1;
        print("%d\n, val");
    }
    
    Variable val is initialized with the highest positive value a signed long integer can hold (2147483647). 
    Adding 1 to the hex value of 0x7fffffff the value of the integer overflows and goes to a negative number (0x7fffffff + 1 = 80000000), 
    in decimal this is -2147483648. Problem is that compilers will not detect this and the application will not notice this issue. 
